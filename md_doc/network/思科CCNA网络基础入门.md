[TOC]

## 1.计算机网络

### 1.1.网络是什么

- 端系统

- 中间系统（NA）

将地理位置不同的多台计算机，

通过通信线路连接起来，

在网络操作系统中，网络管理软件及网络通信协议的管理和协调下，

实现资源共享和信息传递的计算机系统。

### 1.2.网络架构

#### 1.2.1.RS(Router Switch)架构

描述的是中间系统的架构

- PC端

- 交换机
  - Cisco-2900
  - 很多接口
  - 交换机组建的网络，是局域网

- 防火墙（硬件）
  - 火绒（软件）
  - 深信服（软件）
- 路由器
  - Cisco-3640
  - 路由器接口没有交换机的多
  - 路由器有开关，而交换机没有
  - 得办宽带，通过路由器把网线连出去

交换机、路由器的最终目的，是实现通信



端系统是会变化的：PC、手机、IP网络电话

中间系统也是会变化的：WIFI网络

### 1.3.网络的类型

路由器和交换机能实现什么样的网络？

- 局域网（LAN）：一组终端设备和由共同的组织管理的用户
  - 所有的用户，都接在一台交换机下，局域网就形成了
  - 局域网游戏、通信
  - 
- 广域网（WAN）：连接分布于不同地理位置的LAN
  - 分布于不同地理位置的局域网
  - 广域网实质上，就是N多不同的局域网，拼接而成
  - 路由器，是可以把一个局域网的数据，发到另外一个局域网的设备
- 局域网、广域网和Internet之间的关系
  - 路由器出口，连接到哪里？
    - 宽带找谁买的？运营商（ISP）
    - ISP物理层面，可以简单理解为一节一节的路由器
    - ISP的某个路由器，再连接到远程的局域网
    - 最终实现本地和远程通信
  - 不同ISP的局域网（电信、联通、移动）
    - Internet就是，不同ISP的局域网，之间的通信

终端与对端

- 在PC上做的任何事情，都有相应的人，要给你提供服务
  - CS模型
- 凭什么找到对应的服务
  - 下一节

## 2.OSI-TCP分层

凭什么找到对应的服务

应用程序有很多，路由器交换机的厂商有很多，电脑品牌都有很多

中间的这些数据，是如何精确的，传到想要的对端上的?



OSI分层模型来解释，源是怎样通过不同的应用程序，通过不同的中间系统，到不同的目的端

### 2.1.OSI分层

- 20世纪70年代后期，ISO创建OSI参考模型，希望**不同供应商的网络**能够相互协同工作
- OSI：开放互联系统（open system interconnection）
- ISO：国际标准化组织（International Organization for Standardization）

#### 2.1.1.为什么要分层

分层的优点：

1.促进标准化工作，允许各个供应商进行开发

2.各层间相互独立，把网络操作分成低复杂性单元

3.灵活性好，某一层变化不会影响到别层，设计者可专心设计和开发模块功能

类比于快递系统

### 2.2.OSI&TCP/IP

| OSI参考模型 |     TCP/IP协议     |
| :---------: | :----------------: |
|   应用层    |       应用层       |
|   表示层    |       应用层       |
|   会话层    |       应用层       |
|   传输层    |       传输层       |
|   网络层    |     网络互联层     |
|   链路层    |     网络接口层     |
|   物理层    | 网络（链路）接口层 |

常用的是TCP/IP

#### 2.2.1.物理层

部署一个网络，先有第一层

- 物理层的主要作用，是产生并检测电压发送，和接收带有数据的电气信号

- 物理层是不提供数据的纠错服务的，但是在物理层上，能对数据的传输速度作一定的控制，并能检测数据的出错率
- 在物理层传输电器信号的载体我们称之为，位流或比特流

物理层部署的就是网线，就是**接线**

物理层里面走的是数字信号，即比特流

物理层设备

- 屏蔽双绞线（STP）
- 非屏蔽双绞线（UTP）
- 集线器
  - 让比特流信号质检，能够相互交通
- 转化器
- 中继器
  - 还原/放大比特流信号的

猫（调制解调器）不是上网设备，是用来转信号的，数模转换，将数字信号转换为模拟信号，才可以通网

除了网线，还有光纤、无线，都属于物理层接线设备

#### 2.2.2.数据链路层

- 数据链路层决定数据通讯的机制，差错检测
- 提供对网络层的服务
- 合成传输的帧数据

主要对应的是网卡上的Mac地址，类比于车牌号

只有设备上，有Mac地址，才能证明该设备是一个网络设备

数据链路层设备

- 交换机
  - 依赖Mac地址来管理、连接所有的硬件设备

- 网桥
- 网卡

**Mac地址**

Mac地址的结构

由48位二进制数组成，通常表示为12个16进制数

前24位是标准组织（IEEE）制定的，后24位是厂家自己制定的节点标识符，例如：00-IC-25-91-65-48

#### 2.2.3.网络层

因为Mac地址都是唯一的，想要找到对方，就没有什么计算方法

范围一旦扩大，难度就增加了

所以，网络的分层，在有了网线，有了接口Mac，承认它是一个网络设备的基础之上，为了能够把数据在全球范围，又快又准的找到对方，就增加了IP的概念

- 为网络设备提供逻辑地址
  - 不再是看得见，摸得着的东西了
  - IP是用逻辑算法编译出来的地址
  - 既然是逻辑算法编译，就可以通过逻辑算法来选路，找一个最快的路径，这就是为什么我们现在上网这么快
  - 这样的地址，叫做因特网地址，也叫做公网IP？？
  - Mac地址对应的网络，叫做以太网，IP地址对应的网络，叫做因特网
- 负责数据从源端发送到目的端
- 负责数据传输的寻址和转发

网络层设备

- 路由器
  - 依靠IP地址进行逻辑选路最优最快的算法， 把数据传递到目的端，这就是IP存在的意义
- 为什么交换机不能上网？
  - 因为交换机不识别IP，而路由器能

一二三层，满足的是中间系统，接下来就是端系统的分层，都是属于逻辑层

#### 2.2.4.传输层

为了端系统上面的应用程序，一旦想要向网络中转发数据，就需要用到传输层为它传输

也就是说，传输层是专门为应用层提供，端到端的服务的

所以，有应用层，才有传输层，如果应用层不存在，传输层也就不存在

先了解下一小节的应用层



传输层到底为应用层，提供了什么样的服务

- 传输层负责建立端到端的连接，负责数据在端到端之间的传输
- 传输层通过端口号区分上层服务
- TCP（传输控制协议）
  - 面向连接
  - 可靠传输
    - 丢包重传
  - 流控及窗口机制
  - 使用TCP的应用
    - Web浏览器、电子邮件
    - 文件传输程序
- UDP（用户数据报协议）
  - 无连接
  - 不可靠传输
  - 尽力而为的传输
  - 使用UDP的应用
    - 域名系统（DNS）、视频流
    - IP语音（VoIP）

#### 2.2.5.应用层

- 应用层的作用主要是为应用软件，提供接口，从而使得**应用程序**能够使用网络服务
- http,ftp,telnet,dns,smtp...
- 常见端口号，类比于110、112公共的电话号码
  - 每一个端口号，都是对应一个应用程序

| 应用程序 | 默认端口号 |
| :------: | :--------: |
|   HTTP   |     80     |
|   FTP    |     21     |
|  Telnet  |     23     |
|   SMTP   |     25     |
|   DNS    |     53     |
|   TFTP   |     69     |
|   SNMP   |    161     |
|   RIP    |    520     |

- 一个应用程序，就对应于一个服务端口
  - 端口号就是区分应用程序的
  - 应用层提供端口号，传输层按照提供的服务端口，去找到对端的服务程序
  - 这是端到端之间的关系

### 2.3.借助OSI模型来理解数据传输过程

核心：**封装&解封装**

pc通过qq产生了数据，这样的数据被称为应用层数据，只有pc才能明白，这是什么东西，而同样能理解应用层数据的，是对端的服务器。

现在数据要向外传输，应用层就提供了端口号（qq的端口是4000，4000就代表了qq这个应用程序的编号）

应用程序一旦产生，传输层就要提供端到端的服务，传输层与应用层，由于分层不同，传输层要传输应用层数据，不可能直接发到对端的应用层，而只能是传到对端的传输层

为了保证传输层能够传递（通信），在发数据之前，传输层协议，会在数据流之前进行打包（类比于寄快递前打包裹），以阐明用的是TCP还是UDP（假设传输层，使用的是UDP为QQ进行服务）

现在在外面，看不到QQ的数据了，能看到的就只是UDP的包而已

现在要向外传，不知道里面是什么了，对端也不好辨别里面的内容，所以把应用层提供的端口号，放在传输层的报头里

此时UDP报头写着4000端口号，就意味着UDP里面的，是QQ

现在传输层掌握的信息是，我要找对端服务端口号是4000的，但是，只掌握这些信息，能够传嘛？

明显是不够的

就要借助传输层的底层，网络层。网络层提供的是IP地址，也就意味着，要利用提供的IP地址，去寻找对端服务所在的IP地址，到底在哪里

同理，要利用IP去传输的话，包就不能这么传了，IP也要对数据进行一层封装，于是又在数据前面盖了一个报头（IP的部分）

同理，现在在外面，看不到UDP报头里的信息了，能看到的就只是IP的包而已，

为了对数据进行辨别，所以在IP里面有一个叫协议号的东西，用来表明，未来拆掉IP，里面放的是什么传输协议，什么内容（UDP在IP里对应的协议号，是17，这些都是定死的）

此时IP报头写着17的协议号，就意味着拆掉IP后，没有惊喜，里面就是UDP

IP还要有什么呢？要有源IP和目的IP

通过源IP和目的IP，按照IP的逻辑寻址，最快的找到服务所在的IP的那一点，就OK了

至此，IP就已经是一个数据包的形态了，能够向外进行转发了，只要PC能够发到路由器，一跳一跳的，就能找到对方

然而这个数据包，最终是要从物理接口发出，IP只是物理接口的逻辑地址，物理接口上还有一个Mac地址

所以我们的硬件接口要对数据包进行最后一层封装，以太网封装

同理，要加上type（类型位），现在在4层报头中，2层叫类型位，3层叫协议号，4层叫端口号，虽然表示的内容不一样，但是本质上类似，都是表示拆掉之后，我封装的那个东西是什么

除此之外，还有什么信息呢？还有源Mac地址和目的Mac地址，现在数据的封装才算完整。

数据包从PC端发出，第一个承接的，是交换机，交换机是一个二层设备，只可以识别Mac地址

交换机按照源Mac和目的Mac，在局域网进行短距离的传输，传递给路由器

路由器是一个三层设备，在看完源Mac和目的Mac没问题之后，还要按照三层IP的报文去分析，从而进行转发，因为路由器是按照源IP和目的IP去转发的

数据对于路由器而言，被二层挡住了，路由器要看到三层封装的数据，必须要解封装，拆掉之后要看到IP的部分，要看目的IP到底是谁，到底要进行怎样的转发

而路由器往外发的时候，又会封装一个新的以太网，继续去发送

最后到了服务器

服务器是一个七层的，以太网、IP、UDP识别完依次拆掉之后，最后看端口号4000提供的服务的，我也有，是QQ的

服务器的应用程序，对数据进行处理之后，再返回过去，重复上述的全部过程

所以，从应用层到物理层，从上到下，是一个加封装的过程，反之

整个数据的传输过程，就是加封装、解封装重复的过程，只不过中间系统的层数没那么多而已

这也就解释了，为什么厂商不同，应用程序不同，最后还能够传递网络精确匹配？

因为中间的这堆设备，包括源、目的两端，在处理数据的时候，都是按照数据包头进行处理的，只要识别包头就可以了，不用管应用层内部传的是什么内容，类比快递，只要识别地址就够了，不用管里面寄的是什么东西



- 封装时一些专有名词

原始的应用层数据，称为payload（负载）

每个协议的小块，称为报头

被传输层UDP封在了里面，单独的，每一层的协议，像UDP报头的那一小块，称为Head，原来的payload称为数据，数据+报头加在一起，称为报文，UDP那一段的报文，称为segment（段）

IP的报头，与UDP和应用层的部分，IP报头是HEAD，UDP和应用层的部分，又变成了数据，IP的整个报头加数据，称为Packet（数据包）

以太网，又把后面所有的东西封装在一起，对于以太网头部来说，IP部分又变成了数据，以太网头部加数据，称为Frame（帧）

都是一个东西，只不过是封装的层数不一样，交换机转发的是帧，路由器转发的以及网络上传输的是数据包，至于分段、负载都是每个应用层的端去处理的



网工玩的主要是网络层，入门的就是第一件事，就是分配一个合理的IP地址

## 3.IP地址及子网掩码划分

### 3.1.十进制VS二进制数

- 十进制数由0到9表示
- 二进制数由一连串的1和0表示

| 十进制 | 二进制 |
| :----: | :----: |
| 0      | 0 |
| 1      | 1 |
| 2      | 10 |
| 3      | 11 |
| 4      | 100 |
| 5      | 101 |
| 6 | 110 |
| 7 | 111 |
| 8 | 1000 |
| 9 | 1001 |
| 10 | 1010 |
| 11 | 1011 |
| 12 | 1100 |
| 13 | 1101 |
| 14 | 1110 |
| 15 | 1111 |
| 16 | 10000 |
| 17 | 10001 |
| 18 | 10010 |
| 19 | 10011 |

IP地址是三个点分，四个小节

每个小节都是8个比特，十进制的每个小节的大小，是取决于二进制每个小节的大小

由于位数的限制，所以每个小节的最大值是八个一，换算成十进制，是255

所以IP地址的范围是0.0.0.0~255.255.255.255，对于学习IP来说，不需要把32位所有的二进制，全换算成十进制，只需要搞清楚每个小节的换算就可以了

下表，表示每个比特，值为一时代表的十进制数

| 128  |  64  |  32  |  16  |  8   |  4   |  2   |  1   |      |      |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  =   | 128  |
|  1   |  1   |  0   |  0   |  0   |  0   |  0   |  0   |  =   | 192  |
|  1   |  1   |  1   |  0   |  0   |  0   |  0   |  0   |  =   | 224  |
|  1   |  1   |  1   |  1   |  0   |  0   |  0   |  0   |  =   | 240  |
|  1   |  1   |  1   |  1   |  1   |  0   |  0   |  0   |  =   | 248  |
|  1   |  1   |  1   |  1   |  1   |  1   |  0   |  0   |  =   | 252  |
|  1   |  1   |  1   |  1   |  1   |  1   |  1   |  0   |  =   | 254  |
|  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  =   | 255  |

